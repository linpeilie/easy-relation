import{_ as o,X as n,Y as c,Z as t,$ as e,a0 as l,a2 as r,a1 as d,C as i}from"./framework-6ad2459b.js";const s={},_=t("p",null,[e("在关联操作时，首先会把根据配置的关联关系，将所有的参数添加到 "),t("code",null,"Map<String, Object>"),e(" 中，在调用实际方法时， 再将 "),t("code",null,"Map<String, Object>"),e(" 转换为关联查询方法的参数类型实例。针对于该步骤，提供了相应的拓展接口。")],-1),p=t("code",null,"String",-1),h=t("code",null,"Integer",-1),u=t("code",null,"Long",-1),g=d('<h2 id="默认实现" tabindex="-1"><a class="header-anchor" href="#默认实现" aria-hidden="true">#</a> 默认实现</h2><p>默认情况下会使用 JSON 的形式进行转换，即先将 <code>Map&lt;String, Object&gt;</code> 转换为 JSON 字符串，之后再转换为具体入参对象。</p><h2 id="自定义实现" tabindex="-1"><a class="header-anchor" href="#自定义实现" aria-hidden="true">#</a> 自定义实现</h2><p>如果想要自定义该实现时，需要继承 <code>AbstractMapToBeanHandle</code>，实现其 <code>&lt;P&gt; P toBean(final Map&lt;String, Object&gt; map, final Class&lt;P&gt; clazz)</code> 方法。 之后在声明 <code>InjectRelation</code> 实例时，传入该自定义类型即可。</p><p>如果 SpringBoot 运行环境下，可以将该自定义实现声明为 Spring 的 Bean 对象，在项目启动阶段，会自动注入。</p>',5);function f(m,B){const a=i("RouterLink");return n(),c("div",null,[_,t("blockquote",null,[t("p",null,[e("这里需要注意，为了便捷和性能，当关联查询的方法入参类型为 "),p,e("、"),h,e("、"),u,e(" 中的任意一种时， 支持直接不进行额外的转换操作，直接将关联的具体值，赋值给关联查询方法。可以参考"),l(a,{to:"/guide/configure-relation.html#%E5%85%BC%E5%AE%B9%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0"},{default:r(()=>[e("配置关联关系#兼容单个参数")]),_:1})])]),g])}const b=o(s,[["render",f],["__file","to-param.html.vue"]]);export{b as default};
